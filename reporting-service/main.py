from fastapi import FastAPI, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime, timedelta
import sys
import os
import asyncio
import json

# Add shared directory to path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))

from database import get_db, EventLog, OrderAnalytics, CustomerAnalytics, RestaurantAnalytics, DriverAnalytics
from models import UserRole
from auth import get_current_user, require_role
from message_broker import get_message_broker

app = FastAPI(title="Reporting Service", version="1.0.0")

@app.get("/reports/active-counts")
async def get_active_counts(db: Session = Depends(get_db)):
    """Get total active customers, restaurants, and drivers"""
    # This would typically query the respective services
    # For now, return mock data
    return {
        "active_customers": 150,
        "active_restaurants": 25,
        "active_drivers": 40
    }

@app.get("/reports/customer-history/{customer_id}")
async def get_customer_history(
    customer_id: int,
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """Get detailed history of all orders placed by a customer"""
    # Check authorization
    if current_user.role == UserRole.CUSTOMER and current_user.id != customer_id:
        raise HTTPException(status_code=403, detail="Not authorized to view this customer's history")
    
    # Query order analytics
    orders = db.query(OrderAnalytics).filter(
        OrderAnalytics.customer_id == customer_id
    ).offset(skip).limit(limit).all()
    
    return {
        "customer_id": customer_id,
        "orders": orders,
        "total_orders": len(orders)
    }

@app.get("/reports/top-customers")
async def get_top_customers(
    limit: int = 5,
    db: Session = Depends(get_db),
    current_user = Depends(require_role(UserRole.ADMIN))
):
    """Get top customers with highest order frequency"""
    customers = db.query(CustomerAnalytics).order_by(
        CustomerAnalytics.total_orders.desc()
    ).limit(limit).all()
    
    return {
        "top_customers": customers,
        "limit": limit
    }

@app.get("/reports/restaurant-orders")
async def get_restaurant_orders(
    restaurant_id: int,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """Get number of orders received and fulfilled by a restaurant during a specific period"""
    # Check authorization
    if current_user.role == UserRole.RESTAURANT and current_user.id != restaurant_id:
        raise HTTPException(status_code=403, detail="Not authorized to view this restaurant's data")
    
    query = db.query(OrderAnalytics).filter(OrderAnalytics.restaurant_id == restaurant_id)
    
    if start_date:
        query = query.filter(OrderAnalytics.created_at >= start_date)
    if end_date:
        query = query.filter(OrderAnalytics.created_at <= end_date)
    
    orders = query.all()
    
    total_orders = len(orders)
    fulfilled_orders = len([o for o in orders if o.status == "DELIVERED"])
    
    return {
        "restaurant_id": restaurant_id,
        "period": {
            "start_date": start_date,
            "end_date": end_date
        },
        "total_orders": total_orders,
        "fulfilled_orders": fulfilled_orders,
        "fulfillment_rate": (fulfilled_orders / total_orders * 100) if total_orders > 0 else 0
    }

@app.get("/reports/restaurant-revenue")
async def get_restaurant_revenue(
    restaurant_id: int,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """Get breakdown of total revenue generated by a restaurant"""
    # Check authorization
    if current_user.role == UserRole.RESTAURANT and current_user.id != restaurant_id:
        raise HTTPException(status_code=403, detail="Not authorized to view this restaurant's data")
    
    query = db.query(OrderAnalytics).filter(
        OrderAnalytics.restaurant_id == restaurant_id,
        OrderAnalytics.status == "DELIVERED"
    )
    
    if start_date:
        query = query.filter(OrderAnalytics.created_at >= start_date)
    if end_date:
        query = query.filter(OrderAnalytics.created_at <= end_date)
    
    orders = query.all()
    
    total_revenue = sum(order.total_amount for order in orders)
    
    return {
        "restaurant_id": restaurant_id,
        "period": {
            "start_date": start_date,
            "end_date": end_date
        },
        "total_revenue": total_revenue,
        "order_count": len(orders)
    }

@app.get("/reports/popular-menu-items")
async def get_popular_menu_items(
    limit: int = 10,
    db: Session = Depends(get_db)
):
    """Get most ordered menu items across all restaurants"""
    # This would typically aggregate from order items
    # For now, return mock data
    return {
        "popular_items": [
            {"item_name": "Chicken Burger", "order_count": 150, "restaurant": "Burger Palace"},
            {"item_name": "Margherita Pizza", "order_count": 120, "restaurant": "Pizza Corner"},
            {"item_name": "Chicken Wings", "order_count": 95, "restaurant": "Wing Stop"},
            {"item_name": "Caesar Salad", "order_count": 80, "restaurant": "Healthy Bites"},
            {"item_name": "Fish & Chips", "order_count": 75, "restaurant": "Seafood Shack"}
        ],
        "limit": limit
    }

@app.get("/reports/order-status-distribution")
async def get_order_status_distribution(db: Session = Depends(get_db)):
    """Get distribution of order statuses"""
    # This would typically aggregate from order analytics
    # For now, return mock data
    return {
        "status_distribution": {
            "DELIVERED": 450,
            "IN_TRANSIT": 25,
            "PREPARING": 15,
            "CANCELLED": 30,
            "PENDING_PAYMENT": 5
        }
    }

@app.get("/reports/driver-deliveries")
async def get_driver_deliveries(
    driver_id: int,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """Get number of deliveries completed by a driver"""
    # Check authorization
    if current_user.role == UserRole.DRIVER and current_user.id != driver_id:
        raise HTTPException(status_code=403, detail="Not authorized to view this driver's data")
    
    driver_analytics = db.query(DriverAnalytics).filter(
        DriverAnalytics.driver_id == driver_id
    ).first()
    
    if not driver_analytics:
        return {
            "driver_id": driver_id,
            "total_deliveries": 0,
            "total_earnings": 0.0
        }
    
    return {
        "driver_id": driver_id,
        "total_deliveries": driver_analytics.total_deliveries,
        "total_earnings": driver_analytics.total_earnings,
        "last_delivery": driver_analytics.last_delivery_date
    }

@app.get("/reports/cancelled-orders")
async def get_cancelled_orders(
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    db: Session = Depends(get_db),
    current_user = Depends(require_role(UserRole.ADMIN))
):
    """Get details of cancelled orders and total amount"""
    query = db.query(OrderAnalytics).filter(OrderAnalytics.status == "CANCELLED")
    
    if start_date:
        query = query.filter(OrderAnalytics.created_at >= start_date)
    if end_date:
        query = query.filter(OrderAnalytics.created_at <= end_date)
    
    cancelled_orders = query.all()
    total_cancelled_amount = sum(order.total_amount for order in cancelled_orders)
    
    return {
        "cancelled_orders": cancelled_orders,
        "total_cancelled_amount": total_cancelled_amount,
        "order_count": len(cancelled_orders)
    }

@app.get("/reports/average-order-value")
async def get_average_order_value(
    customer_id: Optional[int] = None,
    restaurant_id: Optional[int] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    db: Session = Depends(get_db)
):
    """Calculate average order value"""
    query = db.query(OrderAnalytics).filter(OrderAnalytics.status == "DELIVERED")
    
    if customer_id:
        query = query.filter(OrderAnalytics.customer_id == customer_id)
    if restaurant_id:
        query = query.filter(OrderAnalytics.restaurant_id == restaurant_id)
    if start_date:
        query = query.filter(OrderAnalytics.created_at >= start_date)
    if end_date:
        query = query.filter(OrderAnalytics.created_at <= end_date)
    
    orders = query.all()
    
    if not orders:
        return {"average_order_value": 0.0, "order_count": 0}
    
    total_amount = sum(order.total_amount for order in orders)
    average_value = total_amount / len(orders)
    
    return {
        "average_order_value": average_value,
        "order_count": len(orders),
        "total_amount": total_amount
    }

@app.get("/reports/peak-times")
async def get_peak_times(
    granularity: str = "day",  # day, week, month, year
    db: Session = Depends(get_db)
):
    """Get peak times for orders"""
    # This would typically analyze order timestamps
    # For now, return mock data based on granularity
    if granularity == "day":
        return {
            "granularity": "day",
            "peak_times": [
                {"time_range": "12:00-13:00", "order_count": 45},
                {"time_range": "18:00-19:00", "order_count": 38},
                {"time_range": "19:00-20:00", "order_count": 42}
            ]
        }
    elif granularity == "week":
        return {
            "granularity": "week",
            "peak_days": [
                {"day": "Friday", "order_count": 120},
                {"day": "Saturday", "order_count": 135},
                {"day": "Sunday", "order_count": 110}
            ]
        }
    elif granularity == "month":
        return {
            "granularity": "month",
            "peak_weeks": [
                {"week": "Week 2", "order_count": 450},
                {"week": "Week 3", "order_count": 480},
                {"week": "Week 4", "order_count": 420}
            ]
        }
    elif granularity == "year":
        return {
            "granularity": "year",
            "peak_months": [
                {"month": "December", "order_count": 1800},
                {"month": "November", "order_count": 1650},
                {"month": "October", "order_count": 1550}
            ]
        }

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "reporting-service"}

# Event handlers for async communication
async def handle_all_events(event_data):
    """Handle all events for analytics"""
    event_type = event_data["event_type"]
    data = event_data["data"]
    
    # Log the event
    db = next(get_db())
    event_log = EventLog(
        event_type=event_type,
        order_id=data.get("order_id"),
        user_id=data.get("customer_id"),
        restaurant_id=data.get("restaurant_id"),
        driver_id=data.get("driver_id"),
        data=json.dumps(data)
    )
    db.add(event_log)
    db.commit()
    
    # Update analytics based on event type
    if event_type == "order.created":
        # Update order analytics
        order_analytics = OrderAnalytics(
            order_id=data["order_id"],
            customer_id=data["customer_id"],
            restaurant_id=data["restaurant_id"],
            total_amount=data["total_amount"],
            status="PENDING_PAYMENT"
        )
        db.add(order_analytics)
        db.commit()
    
    elif event_type == "order.delivered":
        # Update completed order analytics
        order_analytics = db.query(OrderAnalytics).filter(
            OrderAnalytics.order_id == data["order_id"]
        ).first()
        if order_analytics:
            order_analytics.status = "DELIVERED"
            order_analytics.completed_at = datetime.utcnow()
            db.commit()
    
    # Update customer analytics
    if "customer_id" in data:
        customer_analytics = db.query(CustomerAnalytics).filter(
            CustomerAnalytics.customer_id == data["customer_id"]
        ).first()
        
        if not customer_analytics:
            customer_analytics = CustomerAnalytics(customer_id=data["customer_id"])
            db.add(customer_analytics)
        
        if event_type == "order.created":
            customer_analytics.total_orders += 1
            customer_analytics.total_spent += data.get("total_amount", 0)
            customer_analytics.last_order_date = datetime.utcnow()
        
        db.commit()
    
    # Update restaurant analytics
    if "restaurant_id" in data:
        restaurant_analytics = db.query(RestaurantAnalytics).filter(
            RestaurantAnalytics.restaurant_id == data["restaurant_id"]
        ).first()
        
        if not restaurant_analytics:
            restaurant_analytics = RestaurantAnalytics(restaurant_id=data["restaurant_id"])
            db.add(restaurant_analytics)
        
        if event_type == "order.created":
            restaurant_analytics.total_orders += 1
            restaurant_analytics.total_revenue += data.get("total_amount", 0)
            restaurant_analytics.last_order_date = datetime.utcnow()
        
        db.commit()
    
    # Update driver analytics
    if "driver_id" in data:
        driver_analytics = db.query(DriverAnalytics).filter(
            DriverAnalytics.driver_id == data["driver_id"]
        ).first()
        
        if not driver_analytics:
            driver_analytics = DriverAnalytics(driver_id=data["driver_id"])
            db.add(driver_analytics)
        
        if event_type == "order.delivered":
            driver_analytics.total_deliveries += 1
            driver_analytics.total_earnings += data.get("delivery_fee", 0)
            driver_analytics.last_delivery_date = datetime.utcnow()
        
        db.commit()

# Start event listeners on startup
@app.on_event("startup")
async def startup_event():
    message_broker = await get_message_broker()
    await message_broker.subscribe_to_events(
        [
            "order.created",
            "order.confirmed",
            "order.accepted",
            "order.preparing",
            "order.ready_for_delivery",
            "order.delivered",
            "order.cancelled",
            "payment.succeeded",
        "payment.failed",
        "driver.assigned"
    ],
    handle_all_events
)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8008)
